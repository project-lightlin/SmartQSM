import numpy as np
import osqp
from scipy import sparse

# A multidimentional implementation of FemPosDeviationSmoother generated by GPT-5
# Reference:
# https://github.com/ApolloAuto/apollo/blob/master/modules/planning/planning_base/math/discretized_points_smoothing/fem_pos_deviation_osqp_interface.h
# https://github.com/ApolloAuto/apollo/blob/master/modules/planning/planning_base/math/discretized_points_smoothing/fem_pos_deviation_osqp_interface.cc
# Usage:
# smoother = FemPosDeviationOsqpInterface()
# smoother.set_ref_points(points) # N x dim
# smoother.set_bounds_around_refs(bounds) # N
# # other params
# if smoother.Solve():
#     output = smoother.opt_points_

class FemPosDeviationOsqpInterface:
    def __init__(self):
        self.ref_points_ = None 
        self.bounds_around_refs_ = None 
        
        self.weight_fem_pos_deviation_ = 1.0e5
        self.weight_path_length_ = 1.0
        self.weight_ref_deviation_ = 1.0

        self.max_iter_ = 4000
        self.time_limit_ = 0.0
        self.verbose_ = False
        self.scaled_termination_ = True
        self.warm_start_ = True

        self.num_of_points_ = 0
        self.dim_ = 0
        self.num_of_variables_ = 0
        self.num_of_constraints_ = 0

        self.opt_points_ = None 

    def set_ref_points(self, ref_points):
        """ref_points: numpy array shape (N, dim)"""
        self.ref_points_ = np.array(ref_points, dtype=float)
        self.num_of_points_, self.dim_ = self.ref_points_.shape

    def set_bounds_around_refs(self, bounds_around_refs):
        self.bounds_around_refs_ = np.array(bounds_around_refs, dtype=float)

    def set_weight_fem_pos_deviation(self, weight_fem_pos_deviation):
        self.weight_fem_pos_deviation_ = weight_fem_pos_deviation

    def set_weight_path_length(self, weight_path_length):
        self.weight_path_length_ = weight_path_length

    def set_weight_ref_deviation(self, weight_ref_deviation):
        self.weight_ref_deviation_ = weight_ref_deviation

    def set_max_iter(self, max_iter):
        self.max_iter_ = max_iter

    def set_time_limit(self, time_limit):
        self.time_limit_ = time_limit

    def set_verbose(self, verbose):
        self.verbose_ = verbose

    def set_scaled_termination(self, scaled_termination):
        self.scaled_termination_ = scaled_termination

    def set_warm_start(self, warm_start):
        self.warm_start_ = warm_start

    def Solve(self):
        # Sanity checks
        if self.ref_points_ is None or len(self.ref_points_) == 0:
            print("reference points empty, solver early terminates")
            return False

        if len(self.ref_points_) != len(self.bounds_around_refs_):
            print("ref_points and bounds size not equal, solver early terminates")
            return False

        if self.num_of_points_ < 3:
            print("ref_points size smaller than 3, solver early terminates")
            return False

        self.num_of_variables_ = self.num_of_points_ * self.dim_
        self.num_of_constraints_ = self.num_of_variables_

        # Calculate kernel (P matrix)
        P = self.CalculateKernel()

        # Calculate affine constraints
        A, lower_bounds, upper_bounds = self.CalculateAffineConstraint()

        # Calculate offset (q vector)
        q = self.CalculateOffset()

        # Primal warm start
        primal_warm_start = self.SetPrimalWarmStart()

        # Setup OSQP problem
        prob = osqp.OSQP()
        osqp_kwargs = dict(
            P=P,
            q=q,
            A=A,
            l=lower_bounds,
            u=upper_bounds,
            verbose=self.verbose_,
            max_iter=self.max_iter_,
            scaled_termination=self.scaled_termination_,
            warm_start=self.warm_start_
        )

        if self.time_limit_ > 0:
            osqp_kwargs["time_limit"] = self.time_limit_

        prob.setup(**osqp_kwargs)

        if self.warm_start_:
            prob.warm_start(x=primal_warm_start)

        # Solve
        res = prob.solve()

        if res.x is None:
            print("Failed to find solution.")
            return False

        # Extract results
        self.opt_points_ = res.x.reshape(self.num_of_points_, self.dim_)
        return True

    def CalculateKernel(self):
        # assert self.num_of_variables_ > 4

        columns = [[] for _ in range(self.num_of_variables_)]
        col_num = 0

        for col in range(self.dim_):
            columns[col].append(
                (col, self.weight_fem_pos_deviation_ +
                    self.weight_path_length_ +
                    self.weight_ref_deviation_))
            col_num += 1

        for col in range(self.dim_, 2 * self.dim_):
            columns[col].append(
                (col - self.dim_, -2.0 * self.weight_fem_pos_deviation_ -
                                self.weight_path_length_))
            columns[col].append(
                (col, 5.0 * self.weight_fem_pos_deviation_ +
                    2.0 * self.weight_path_length_ +
                    self.weight_ref_deviation_))
            col_num += 1

        second_point_from_last_index = self.num_of_points_ - 2
        for point_index in range(2, second_point_from_last_index):
            col_index = point_index * self.dim_
            for col in range(self.dim_):
                col_index_with_dim = col_index + col
                columns[col_index_with_dim].append(
                    (col_index_with_dim - 2 * self.dim_, self.weight_fem_pos_deviation_))
                columns[col_index_with_dim].append(
                    (col_index_with_dim - self.dim_, -4.0 * self.weight_fem_pos_deviation_ -
                                                    self.weight_path_length_))
                columns[col_index_with_dim].append(
                    (col_index_with_dim, 6.0 * self.weight_fem_pos_deviation_ +
                                        2.0 * self.weight_path_length_ +
                                        self.weight_ref_deviation_))
                col_num += 1

        second_point_col_from_last_col = self.num_of_variables_ - 2 * self.dim_
        last_point_col_from_last_col = self.num_of_variables_ - self.dim_
        for col in range(second_point_col_from_last_col,
                        last_point_col_from_last_col):
            columns[col].append(
                (col - 2 * self.dim_, self.weight_fem_pos_deviation_))
            columns[col].append(
                (col - self.dim_, -4.0 * self.weight_fem_pos_deviation_ -
                                self.weight_path_length_))
            columns[col].append(
                (col, 5.0 * self.weight_fem_pos_deviation_ +
                    2.0 * self.weight_path_length_ +
                    self.weight_ref_deviation_))
            col_num += 1

        for col in range(last_point_col_from_last_col, self.num_of_variables_):
            columns[col].append(
                (col - 2 * self.dim_, self.weight_fem_pos_deviation_))
            columns[col].append(
                (col - self.dim_, -2.0 * self.weight_fem_pos_deviation_ -
                                self.weight_path_length_))
            columns[col].append(
                (col, self.weight_fem_pos_deviation_ +
                    self.weight_path_length_ +
                    self.weight_ref_deviation_))
            col_num += 1

        assert col_num == self.num_of_variables_, f"col_num {col_num} != self.num_of_variables_ {self.num_of_variables_}"

        data, row_index, col_ptr = [], [], []
        ind_p = 0
        for i in range(col_num):
            col_ptr.append(ind_p) 
            for row, val in columns[i]:
                data.append(val * 2.0)
                row_index.append(row)
                ind_p += 1
        col_ptr.append(ind_p) 

        P = sparse.csc_matrix((data, row_index, col_ptr),
                            shape=(self.num_of_variables_, self.num_of_variables_))
        return P

    def CalculateOffset(self):
        q = []
        for i in range(self.num_of_points_):
            for d in range(self.dim_):
                q.append(-2.0 * self.weight_ref_deviation_ * self.ref_points_[i, d])
        return np.array(q)

    def CalculateAffineConstraint(self):
        A = sparse.eye(self.num_of_variables_, format='csc')
        lower_bounds = []
        upper_bounds = []
        for i in range(self.num_of_points_):
            bound = self.bounds_around_refs_[i]
            for d in range(self.dim_):
                lower_bounds.append(self.ref_points_[i, d] - bound)
                upper_bounds.append(self.ref_points_[i, d] + bound)
        return A, np.array(lower_bounds), np.array(upper_bounds)

    def SetPrimalWarmStart(self):
        return self.ref_points_.flatten()



if __name__ == '__main__':
        
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D  # noqa: F401
    np.random.seed(0)

    t = np.linspace(0, 10, 100)
    curve = np.sin(t)

    # 这里是三维测试
    x = t
    y = curve
    z = t ** 2
    points = np.column_stack((x, y, z))

    # 加上随机偏移
    max_offset = 0.1
    offset = np.random.uniform(0, max_offset, size=points.shape)
    points_noisy = points + offset

    bounds = np.full(shape=points.shape[0], fill_value=max_offset)

    smoother = FemPosDeviationOsqpInterface()
    smoother.set_ref_points(points_noisy)
    smoother.set_bounds_around_refs(bounds)
    smoother.set_verbose(True)

    if smoother.Solve():
        output = smoother.opt_points_

        dim = points.shape[1]
        if dim == 2:
            plt.plot(points_noisy[:, 0], points_noisy[:, 1], c="#0000ff", marker="x", label="raw path")
            plt.plot(output[:, 0], output[:, 1], c="#ff0000", marker="o", label="smoothed path")
            plt.legend()
            plt.title('FemPosDeviationSmoother 2D')
            plt.show()
        elif dim == 3:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection='3d')
            ax.plot(points_noisy[:, 0], points_noisy[:, 1], points_noisy[:, 2],
                    c="#0000ff", marker="x", label="raw path")
            ax.plot(output[:, 0], output[:, 1], output[:, 2],
                    c="#ff0000", marker="o", label="smoothed path")
            ax.legend()
            ax.set_title('FemPosDeviationSmoother 3D')
            plt.show()
        else:
            print("Unsupported dimension:", dim)