
import numpy as np
from scipy.optimize import minimize
from numba import njit

# A high-performance implementation of cylinder fitting generated by GPT-5
# https://www.geometrictools.com/Samples/Mathematics.html#FitCylinder

@njit
def projection_matrix(w):
    wx, wy, wz = w
    return np.array([
        [1 - wx*wx, -wx*wy, -wx*wz],
        [-wy*wx, 1 - wy*wy, -wy*wz],
        [-wz*wx, -wz*wy, 1 - wz*wz]
    ], dtype=np.float64)


@njit
def skew_matrix(w):
    wx, wy, wz = w
    return np.array([
        [0.0, -wz, wy],
        [wz, 0.0, -wx],
        [-wy, wx, 0.0]
    ], dtype=np.float64)


@njit
def prepare_matrices(w, Xs):
    P = projection_matrix(w)
    Ys = Xs @ P.T
    A = Ys.T @ Ys
    S = skew_matrix(w)
    A_hat = S @ A @ S.T
    Ys_norm2 = np.sum(Ys * Ys, axis=1)
    return P, S, A, A_hat, Ys, Ys_norm2


@njit
def calc_G(w, Xs):
    P, S, A, A_hat, Ys, Ys_norm2 = prepare_matrices(w, Xs)
    wgt_Ys = (Ys_norm2[:, None] * Ys).sum(axis=0)
    denom = np.trace(A_hat @ A)
    if abs(denom) < 1e-14:
        return np.inf
    v = (A_hat @ wgt_Ys) / denom
    u = Ys_norm2.mean()
    d = Ys_norm2 - u - 2 * (Ys @ v)
    return np.dot(d, d)


@njit
def calc_C(w, Xs):
    _, S, A, A_hat, Ys, Ys_norm2 = prepare_matrices(w, Xs)
    wgt_Ys = (Ys_norm2[:, None] * Ys).sum(axis=0)
    denom = np.trace(A_hat @ A)
    if abs(denom) < 1e-14:
        return np.zeros(3)
    return (A_hat @ wgt_Ys) / denom


@njit
def calc_r(w, Xs):
    P = projection_matrix(w)
    c = calc_C(w, Xs)
    deltas = Xs - c
    dP = deltas @ P.T
    dists2 = np.sum(deltas * dP, axis=1)
    return np.sqrt(np.mean(dists2))


def direction(theta, phi):
    st = np.sin(theta)
    return np.array([
        np.cos(phi) * st,
        np.sin(phi) * st,
        np.cos(theta)
    ], dtype=float)


def preprocess_data(Xs_raw):
    Xs_raw = np.asarray(Xs_raw, dtype=float)
    Xs_mean = Xs_raw.mean(axis=0, keepdims=True)
    return Xs_raw - Xs_mean, Xs_mean[0]


def fit(data, guess_angles=None):
    Xs, Xs_mean = preprocess_data(data)
    Xs = np.asarray(Xs)

    if guess_angles is not None:
        start_points = guess_angles
    else:
        start_points = [(0, 0), (np.pi / 2, 0), (np.pi / 2, np.pi / 2)]
        start_points += [(np.random.rand() * np.pi, np.random.rand() * 2 * np.pi) for _ in range(3)]

    best_res = None
    best_error = np.inf

    for sp in start_points:
        def obj(x):
            w = direction(x[0], x[1])
            return calc_G(w, Xs)

        res = minimize(obj, sp, method='L-BFGS-B',
                       tol=1e-6, options={'maxiter': 300})
        if res.fun < best_error:
            best_error = res.fun
            best_res = res

    theta, phi = best_res.x
    w = direction(theta, phi)
    c = calc_C(w, Xs) + Xs_mean
    radius = calc_r(w, Xs)
    error = best_res.fun

    return w, c, radius, error

# Strategy used by TreeQSM
from .numpy_extra import calculate_distances_from_points_to_line
from typing import Tuple
def fit_cylinder(points: np.ndarray, inlier_rate: float = 0.9) -> Tuple[np.ndarray,np.ndarray, float]:
    axis_direction: np.ndarray
    centroid: np.ndarray
    radius: float

    if inlier_rate == 1.:
        axis_direction, centroid, radius, _ = fit(points)
    else:
        axis_direction, centroid, radius, _ = fit(points)
        squared_residuals: np.ndarray = (calculate_distances_from_points_to_line(points, centroid, centroid + axis_direction) - radius) ** 2
        threshold: float = np.percentile(squared_residuals, 100 * inlier_rate)
        axis_direction, centroid, radius, _ = fit(points[squared_residuals <= threshold])
        
    return axis_direction, centroid, radius