# SmartQSM - project-lightlin.github.io
# 
# Copyright (C) 2025-, YANG Jie <nj_yang_jie@foxmail.com>
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or 
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
from typing import Optional, Tuple, List, Dict, Union, Callable, Any, Generator
import open3d as o3d
from scipy.spatial import Delaunay, KDTree
import networkx as nx
import matplotlib.cm as cm
from utils.networkx_extra import weight_edges_by_node_data
from .pipeline import Pipeline

class SkeletonizationBase(Pipeline):
    _edge_weight_function_to_fn: Dict[str, Callable[[Tuple[np.ndarray, Optional[np.ndarray]], Tuple[np.ndarray, Optional[np.ndarray]]], float]]

    _edge_search_param: Optional[float]
    _edge_weight_function: Optional[str]
    _topology_extractor: str
    
    _points: Optional[np.ndarray]
    _edges: Optional[List[Tuple[int, int]]]
    _skeletal_points: Optional[np.ndarray]
    _skeleton: Optional[nx.DiGraph]
    _radii: Optional[np.ndarray]
    _graph: Optional[nx.Graph]
    _clusters: Optional[List[np.ndarray]]

    def _clear(self) -> None:
        self._edge_search_param = None
        self._edge_weight_function = None
        self._topology_extractor = None

        self._points = None
        self._edges = None
        self._graph = None
        self._clusters = None
        return 

    def __init__(
            self, 
            verbose
    ) -> None:
        super().__init__(
            verbose=verbose
        )

        self._edge_weight_function_to_fn = {
            # Vertex Data: (Skeletal point index, Surface point ids in cluster)
            "l2_norm": lambda u_data, v_data : np.linalg.norm(self._skeletal_points[u_data[0]] - self._skeletal_points[v_data[0]]),
            "squared_l2_norm": lambda u_data, v_data: np.linalg.norm(self._skeletal_points[u_data[0]] - self._skeletal_points[v_data[0]]) ** 2
        }

        self._skeletal_points = None
        self._skeleton = None
        self._radii = None

        self._clear()
        return

    def _add_edge_weight_function(self, key: str, value: Callable[[Tuple[np.ndarray, Optional[np.ndarray]], Tuple[np.ndarray, Optional[np.ndarray]]], float]) -> None:
        self._edge_weight_function_to_fn[key] = value
        return

    def _convert_edge_search_param(self) -> Union[float, np.ndarray]:
        # Can be overrided to achieve point by point search radius
        if self._edge_search_param >= 2.:
            if int(self._edge_search_param) != self._edge_search_param:
                raise ValueError(f"edge_search_param should be < 0 (disabled) or == 0 or (0., 2.) or [2,3,...), but got {self._edge_search_param}.")
            k: int = int(self._edge_search_param)
            return k
        return self._edge_search_param

    def _construct_graph(self) -> Optional[Tuple[str, o3d.geometry.PointCloud, o3d.geometry.LineSet]]:
        # Perform delaunay tetrahedralization and fuse edges
        if self._edge_search_param < 0.:
            # Do not execute. 
            pass
        else:
            simplices: np.ndarray = Delaunay(self._skeletal_points).simplices
            start_nodes: np.ndarray = np.concatenate([
                simplices[:, 0],
                simplices[:, 0],
                simplices[:, 0],
                simplices[:, 1],
                simplices[:, 1],
                simplices[:, 2],
            ])
            end_nodes: np.ndarray = np.concatenate([
                simplices[:, 1],
                simplices[:, 2],
                simplices[:, 3],
                simplices[:, 2],
                simplices[:, 3],
                simplices[:, 3],
            ])
            
            edges: np.ndarray
            # Remove duplication
            if self._edge_search_param == 0.:
                # Add all edges generated by Delaunay tetrahedron
                tet_edges: np.ndarray = np.column_stack((start_nodes, end_nodes))
                if isinstance(self._edges, list) and len(self._edges) > 0:
                    edges = np.concatenate([self._edges, tet_edges], axis=0)
                else:
                    edges = tet_edges
            else:
                kdtree: KDTree = KDTree(self._skeletal_points)
                neighbor_point_ids_per_point: List[List[int]]
                # Neighbor relationships can construct connection relationships, and tetrahedra provide connectivity
                if self._edge_search_param >= 2:
                    neighbor_point_ids_per_point: List[List[int]] = kdtree.query(self._skeletal_points, k=self._convert_edge_search_param())[1]
                else:
                    neighbor_point_ids_per_point: List[List[int]] = kdtree.query_ball_point(self._skeletal_points, r=self._convert_edge_search_param())

                neighborhood_edges: Union[List[np.ndarray], np.ndarray] = []
                for i, neighbor_point_ids in enumerate(neighbor_point_ids_per_point):
                    neighborhood_edges.append(np.column_stack((
                        np.ones(len(neighbor_point_ids), dtype=int) * i,
                        neighbor_point_ids
                    )))
                
                tet_edge_weights: np.ndarray = np.linalg.norm(
                    self._skeletal_points[start_nodes] - self._skeletal_points[end_nodes],
                    axis=1
                )

                tet_graph: nx.Graph = nx.Graph()
                tet_graph.add_weighted_edges_from(zip(start_nodes, end_nodes, tet_edge_weights))
                tet_edges: np.ndarray = np.array([(edge[0], edge[1]) for edge in list(nx.minimum_spanning_edges(tet_graph))])

                neighborhood_edges = np.concatenate(
                    neighborhood_edges + [tet_edges],
                    axis=0
                )

                # Filter out (v, v)
                mask: np.ndarray = neighborhood_edges[:, 0] != neighborhood_edges[:, 1]
                neighborhood_edges = neighborhood_edges[mask]
                
                if isinstance(self._edges, list) and len(self._edges) > 0:
                    edges = np.concatenate([self._edges, neighborhood_edges], axis=0)
                else:
                    edges = neighborhood_edges
            # Remove duplicate undirected edges
            edges.sort(axis=1)
            unique_edges: np.ndarray = np.unique(edges, axis=0)
            self._edges = unique_edges.tolist()

        self._graph = nx.Graph()
        node_to_point_and_cluster: Dict[int, Tuple[np.ndarray, Optional[np.ndarray]]] = {}
        for i in range(len(self._skeletal_points)):
            node_to_point_and_cluster[i] = (
                i, 
                self._clusters[i] if self._clusters is not None else None 
            )

        weighted_edges: List[Tuple[int, int, Dict[str, float]]] = weight_edges_by_node_data(
            self._edges, 
            node_to_point_and_cluster, 
            self._edge_weight_function_to_fn[self._edge_weight_function]
        )
        
        self._graph.add_edges_from(weighted_edges)
        
        if not self._verbose:
            return
        
        cloud: o3d.geometry.PointCloud = o3d.geometry.PointCloud()
        cloud.points = o3d.utility.Vector3dVector(self._skeletal_points)
        cloud.paint_uniform_color([1.0, 0.0, 0.0])
        lineset: o3d.geometry.LineSet = o3d.geometry.LineSet()
        lineset.points = o3d.utility.Vector3dVector(self._skeletal_points)
        lineset.lines = o3d.utility.Vector2iVector(self._edges)
        lineset.colors = o3d.utility.Vector3dVector(
            np.tile([0.5, 0.5, 0.5], (len(self._edges), 1))
        )
        return f"Generated a graph with {len(self._edges)} edge(s) for skeleton extaction.", cloud, lineset
    
    def _extract_skeleton(self) -> Optional[Tuple[str, o3d.geometry.PointCloud, o3d.geometry.LineSet]]:
        # Produce skeleton
        root_node: int = np.argmin(
            self._skeletal_points[
                np.array(list(max(nx.connected_components(self._graph), key=len))), # In case of graph disconnection and index modification
                2
            ]
        )
        
        if self._topology_extractor == "spt":
            self._skeleton = nx.DiGraph()
            node_to_predecessors: Dict[int, List[int]] = nx.dijkstra_predecessor_and_distance(
                self._graph,
                root_node
            )[0]

            for node, predecessors in node_to_predecessors.items():
                if len(predecessors) == 0:
                    continue

                self._skeleton.add_edge(
                    predecessors[0], 
                    node, 
                    weight=np.linalg.norm(self._skeletal_points[predecessors[0]] - self._skeletal_points[node])
                )
        elif self._topology_extractor == "mst":
            mst: nx.Graph = nx.minimum_spanning_tree(self._graph)
            self._skeleton = nx.dfs_tree(mst, source=root_node)
            for u, v in self._skeleton.edges:
                self._skeleton[u][v]["weight"] = np.linalg.norm(self._skeletal_points[u] - self._skeletal_points[v])
        else:
            raise NotImplementedError(f"Topology extractor {self._topology_extractor} is not implemented.")
        
        if not self._verbose:
            return
        
        cloud: o3d.geometry.PointCloud = o3d.geometry.PointCloud()
        cloud.points = o3d.utility.Vector3dVector(self._skeletal_points)
        cloud.paint_uniform_color([1.0, 0.0, 0.0])

        lineset: o3d.geometry.LineSet = o3d.geometry.LineSet()
        lineset.points = o3d.utility.Vector3dVector(self._skeletal_points)
        lineset.lines = o3d.utility.Vector2iVector([(u, v) for u, v in self._skeleton.edges])
        lineset.colors = o3d.utility.Vector3dVector(
            np.tile([0.0, 0.0, 0.0], (len(self._skeleton.edges), 1))
        )

        return f"Extracted the skeleton ({self._skeleton.number_of_edges()} edges).", cloud, lineset

    def set_params(
            self,
            *,
            edge_search_param: float = 0.,
            edge_weight_function: str = "squared_l2_norm",
            topology_extractor: str = "spt"
    ) -> None:
        self._edge_search_param = edge_search_param
        self._edge_weight_function = edge_weight_function
        self._topology_extractor = topology_extractor

        super()._clear_pipeline()
        super()._add_fns_to_pipeline(len(self._pipeline), [
            self._construct_graph,
            self._extract_skeleton
        ])
        return
    
    def run(self, points: np.ndarray) -> Generator[Any, None, Tuple[np.ndarray, nx.DiGraph, np.ndarray]]:
        self._skeletal_points = None
        self._skeleton = None
        self._radii = None

        self._points = points
        
        for fn in self._pipeline:
            yield fn()

        self._clear()
        return self._skeletal_points, self._skeleton, self._radii
    